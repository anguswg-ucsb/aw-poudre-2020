#' ---
#' title: "Flow Preference Values on the Poudre River"
#' author: "Lynker"
#' date: "2020-06-22"
#' output: github_document
#' ---
#'
#' This script computes where each flow preference curve crosses zero for
#' the various Poudre River reaches. 

# Load packages
library(tidyverse)
library(here)

# Import data
# Note .RData files are in gitignore, so these must be on your local machine
load(file = here("flow_pref", "survey-analysis", "respondend-attributes.Rdata"))
load(file = here("flow_pref", "survey-analysis", "flow-pref-data.Rdata"))

# Convert flow to numeric
flowpref.dat <- flowpref.dat %>% 
  mutate(flow = as.numeric(flow))

# Assign all users an experience code
respondent.attributes <- respondent.attributes %>% 
  mutate(skill = case_when(skill.novice == T ~ "novice",
                           skill.intermediate == T ~ "intermed",
                           skill.advanced == T ~ "advanced",
                           skill.expert == T ~ "expert"))

# Next a list of unqualified respondent IDs based on:
# 1) skill level (remove novice)
# 2) trip frequency (remove 1 trip per season)
# 3) reporting confidence (remove Not comfortable at all)

# Create thresholds for each category
skill_thresh = "novice"
trip_thresh = "1 time a season"
confidence_thresh = "Not comfortable at all"

# Make a vector of respondent IDs above the thresholds
respondent.id.valid = respondent.attributes %>% 
  filter(., skill != skill_thresh,
         trip.frequency != trip_thresh,
         reporting.confidence != confidence_thresh) %>% 
  pull(., respondent.id)

# Filter the flow pref data to valid respondents only
# where rows have preference codes
flowpref.dat <- flowpref.dat %>% 
  filter(., respondent.id %in% respondent.id.valid &
           !is.na(preference.code))

# Summarize by flow and segment
results <- flowpref.dat %>% 
  group_by(segment.name, flow) %>%
  summarize(pref.average = mean(preference.code),   # average preference
            d = sum(abs(dist(preference.code))),    # sum of the score distance vector
            m = sum(abs(dist(rep(c(-3,3),n())))),   # maximum possible sum of distance vector
            pci2 = d/m,                             # PCI2 = d/m
            n_obs = length(flow))  %>% 
  mutate(flow_of_max_pref = nth(flow,
                                which.max(pref.average))) 
# Last line of above code returns the flow value at which the maximum preference
# is recorded -- this will be used for filtering below

# Calculate the zero crossing for each segment
# This is done by the uniroot function, which calculates where the curve
# generated by approxfun crosses zero
flow_pref <- results %>% 
  filter(., flow <= flow_of_max_pref) %>% 
  group_by(segment.name) %>% 
  summarize(flow_pref = uniroot(approxfun(flow, pref.average), 
                                interval = range(flow))[["root"]])

# Output into a table
flow_pref %>% knitr::kable(., caption = "Flow and Stage Preference Values")


# Keith Jennings
# kjennings@lynkertech.com
# 2020-06-22